# Online_Chat_Messenger
Recursion project

## ステージ1
推奨使用言語: Python（サーバとクライアント両方で）

### 内容
このステージでは、クライアントがサーバに接続する形式のチャットメッセンジャーサービスを作成します。サーバはバックグラウンドで稼働し、一方でクライアントは CLI を通じてサーバに接続します。接続が確立された後、クライアントはメッセージを入力してサーバに送り、そのメッセージはサーバに接続している他の全てのクライアントにも配信されます。

### 機能要件
サーバは CLI で起動し、バックグラウンドで着信接続を待ち受けます。もしサーバがオフラインであれば、それはチャットサービス自体が停止しているということです。

- サーバとクライアントは、UDP ネットワークソケットを使ってメッセージのやり取りをします。
- メッセージ送信時、サーバとクライアントは一度に最大で 4096 バイトのメッセージを処理します。これは、クライアントが送信できるメッセージの最大サイズです。同じく、最大 4096 バイトのメッセージが他の全クライアントに転送されます。
- セッションが開始される際には、クライアントはユーザーにユーザー名を入力させます。
- メッセージの送信プロトコルは比較的シンプルです。メッセージの最初の 1 バイト、usernamelen は、ユーザー名の全バイトサイズを示し、これは最大で 255バイト（28 - 1 バイト）になります。サーバはこの初めの usernamelen バイトを読み、送信者のユーザー名を特定します。その後のバイトは送信される実際のメッセージです。この情報はサーバとクライアントによって自由に使用され、ユーザー名の表示や保存が可能です。
- バイトデータは UTF-8 でエンコードおよびデコードされます。これは、1 文字が 1 から 4 バイトで表現される意味です。Python の str.encode と str.decode メソッドは、デフォルトでこの挙動を持っています。
- サーバにはリレーシステムが組み込まれており、現在接続中のすべてのクライアントの情報を一時的にメモリ上に保存します。新しいメッセージがサーバに届くと、そのメッセージは現在接続中の全クライアントにリレーされます。
- クライアントは、何回か連続で失敗するか、しばらくメッセージを送信していない場合、自動的にリレーシステムから削除されます。この点で TCP と異なり、UDP はコネクションレスであるため、各クライアントの最後のメッセージ送信時刻を追跡する必要があります。

#### 非機能要件
- チャットメッセージングシステムは、リアルタイムのデータの優先度が信頼できるデータよりも高いとされています。
- システムは、毎秒最低で 10,000 パケットの送信をサポートする必要があります。例えば、1000 人が一つのチャットルームにいる場合、システムは毎秒最低でも 10 メッセージを処理できるように設計されているべきです。

一般的なハードウェアを使用した場合でも、UDP パケットの取り扱いはこれらの非機能要件を満たす必要があります。


## ステージ2

推奨使用言語: Python（サーバとクライアント両方で）

### 内容
このステージでは、クライアントが自分自身でチャットルームをホストし、他の招待された人々がそのルームに参加できるようなチャットメッセンジャーシステムを作成します。クライアントは CLI を通じてサーバとやりとりを行います。ユーザーは自分で新しいチャットルームを作成するか、あるいは既存のチャットルームに名前を指定して参加することができます。また、チャットルームはパスワードで保護されている場合もあり、その際には正確なパスワードを入力しないと参加できません。

内部的な動きとしては、新しいチャットルームを作成するプロセスや既存のチャットルームに参加するためには、最初に TCP 接続が用いられます。サーバは特定の「クライアントトークン」を生成してクライアントに送り、その後 TCP 接続を閉じます。クライアントはこのトークンを持って、UDP を経由してサーバが管理するチャットルームに接続します。そうすることで、チャットルーム内の他のユーザーとコミュニケーションを取ることが可能になります。

### 機能要件
チャットルームの作成と接続（TCP）

- カスタム TCP プロトコルを作成し、クライアントとサーバがチャットルームの作成と接続のために通信できるようにします。TCP は、メッセージの受信と順序が保証されるため、信頼性が高いです。以下は、チャットルームプロトコル（TCRP）と呼ぶカスタムプロトコルです。
  - ヘッダー（32 バイト）: RoomNameSize（1 バイト） | Operation（1 バイト） | State（1 バイト） | OperationPayloadSize（29 バイト）
  - ボディ: 最初の RoomNameSize バイトがルーム名で、その後に OperationPayloadSize バイトが続きます。ルーム名の最大バイト数は 28 バイトであり、OperationPayloadSize の最大バイト数は 229 バイトです。
- RoomNames は UTF-8 でエンコード/デコードされます。OperationPayload は、操作と状態に応じて異なる方法でデコードされる可能性があります（整数、文字列、JSON ファイルなど）
- 新しいチャットルームを作成する場合、操作コードは 1 です。0 はリクエスト、1 は準拠、2 は完了です。TCP は完全なトランザクションを保証するために使用されます。
  - サーバの初期化（0）: クライアントが新しいチャットルームを作成するリクエストを送信します。ペイロードには希望するユーザー名が含まれます。
  - リクエストの応答（1）: サーバはステータスコードを含むペイロードで即座に応答します。
  - リクエストの完了（2）: サーバは特定の生成されたユニークなトークンをクライアントに送り、このトークンにユーザー名を割り当てます。このトークンはクライアントをチャットルームのホストとして識別します。トークンは最大 255 バイトです。
- 新しいチャットルームに参加しようとするとき、操作コードは 2 です。状態は作成時と同様で、クライアントも生成されたトークンを受け取りますが、ホストではありません。
- チャットルームごとに、サーバは許可されたリストトークンのリストを追跡する必要があります。ユーザーがそのトークンで参加すると、トークンの所有者として設定されます。メッセージがチャットルーム内の他のすべての人にリレーされるためには、トークンと IP アドレスが一致しなければなりません。
- チャットルームの作成またはチャットルームへの参加が完了すると、TCP コネクションは終了します。クライアントは自動的に UDP でサーバに接続します。

#### ルームでのチャット（UDP）

- チャットルームはホストが存在する限り有効です。ホストが退出すると、チャットルームは自動的に閉じられます。
- チャットルームに参加するには、専用の許可トークンが必要です。このトークンは参加者の IP アドレスと一致する必要があります。
- クライアントとサーバ間でのメッセージ交換は、すべて UDP プロトコルを使用して行われます。
- クライアントがサーバに送信するパケットは、最大 4096 バイトのメッセージとなります。そのうちの最初の 2 バイトは、ルーム名とトークンのバイトサイズを示しています。
  - ヘッダー: RoomNameSize（1 バイト）| TokenSize（1 バイト）
  - ボディ: 最初の RoomNameSize バイトはルーム名、次の TokenSize バイトはトークン文字列、そしてその残りが実際のメッセージです。
- クライアントはサーバから最大で 4094 バイトのパケットを受信できます。これはメッセージのみで、ヘッダーは含まれません。
- クライアントがリレーシステムから削除された場合、そのトークンもサーバから削除されます。サーバは切断メッセージを該当のクライアントに転送します。その後、クライアントは再度チャットルームに参加する必要があります。
- その他のチャットに関する要件は、ステージ 1 で述べた内容と同様です。この設計によって、クライアントが自分自身でチャットルームをホストし、大規模なネットワーク内で運用できるようになりました。

### 非機能要件
- チャットメッセージングシステムは、リアルタイムのデータの優先度が信頼できるデータよりも高いとされています。
- システムは、毎秒最低 10,000 パケットの送信をサポートする必要があります。具体的には、例えば 500 のチャットルームがあり、それぞれのルームで 10 人が毎秒平均 2 メッセージを送信するような状況もサポートできるようになっているべきです。

## ステージ3

このステージでは、より高度な機能と要件が求められ、その実装にはかなりの労力が必要です。


### パスワード

- コードベースのリファクタリングを行い、ペイロードが常に JSON 形式でデコードされるようにします。
- チャットルームを作成するとき、ホストはパスワードのオプション引数を渡すことができ、パスワードを持つクライアントだけがチャットルームに参加することができます。
- クライアントは、チャットルームに参加する際にオプションの引数としてパスワードを渡すことができます。チャットルームがパスワードで保護されている場合、このパスワードが正しく一致する必要があります。

#### クライアントとしてデスクトップアプリケーションを作成

JavaScript または TypeScript、Electron.js を使用します。Electron.js は Node.js を使用しており、JS コードはブラウザ上ではなく、オペレーティングシステム上で実行されます。

- ユーザーが簡単にチャットルームを作成し、参加できるデスクトップアプリケーションを作成します。
- アプリには、ユーザーがチャットルームを作成するか参加するかを選択するナビゲーションがあります。
- チャットルームを作成する場合、ユーザーはユーザー名とチャットルーム名を入力してチャットルームを作成し、サーバに接続します。
- チャットルームに参加する場合、ユーザーは自動的にチャットルーム GUI に参加し、テキストを入力したり、参加以降のすべてのメッセージを上下にスクロールすることができます。
- 
#### メッセージの暗号化

暗号化方式として、RSA に似た手法を使用して、サーバとクライアント間で送受信されるすべてのメッセージを保護します。クライアントとサーバは、送受信するすべてのメッセージを以下の暗号化方式で処理します。

##### クライアントの手順：

- クライアントはローカル環境で秘密鍵と公開鍵を生成します。
- サーバへの接続要求を行う際に、生成した公開鍵をサーバに送信します。
- サーバはこの公開鍵を保存し、この鍵を用いてメッセージを暗号化した後でクライアントに送信します。
- メッセージに含まれるトークンを復号化する唯一の方法は、正確な秘密鍵を使用することです。クライアントはローカルに保存された秘密鍵で復号化を行います。

##### 逆のプロセス：

- すべてのクライアントは、初めにサーバからその公開鍵を取得します。
- クライアントがサーバにメッセージを送る際は、このサーバの公開鍵を使用してメッセージを暗号化する必要があります。

これらがメッセージ暗号化における主要な要件と手順です。


### 拡張性

拡張性について実装する必要はありませんが、以下の非機能要件について考慮してみてください。

チャットメッセージングシステムは、少なくとも毎秒 10,000 パケットの送信に対応できるようにしてください。たとえば、1 秒に平均で 2 メッセージを送る 10 人がいる 500 個のチャットルームをサポートできると考えられます。

もし WhatsApp や LINE のような大規模なサービスになると、どうなるでしょうか。これらのメッセージングアプリには数億から数十億のユーザーがいます。ピーク時には 4 億人がアクティブで、各ユーザーが 10 分に 1 回メッセージを送ると仮定した場合、平均して 20% のユーザーが 4 人グループに参加しているとしましょう。この条件下で、1 秒間に送信されるパケット数を計算してみてください。

ピーク時に多数のユーザーをサポートする場合、1 秒間にどれだけのパケットを送信できるのか考慮が必要です。具体的には以下の点を考えてみましょう。

##### ロードバランシング

ロードバランサーはネットワークトラフィックを複数のサーバに効率よく振り分けます。もし 1 台のサーバが 1 秒間に 10,000 パケットを処理できるとしたら、その影響は 1 秒間に処理されるソケットの総数にどう出るでしょうか？

##### 並行処理

一つのコアで 1 秒間に 10,000 ソケットを処理できるかもしれませんが、16 コアでプログラムを実行できるとしたら、どうなるでしょうか？

##### 分散プログラミング

特定のタスクが小さなサブタスクに分けられ、それが複数のコアを持ついくつかのマシンに分散される場合、1 秒間に処理できるソケットの総数はどれくらいになるでしょうか？

---
